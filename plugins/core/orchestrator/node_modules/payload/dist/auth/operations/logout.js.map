{"version":3,"sources":["../../../src/auth/operations/logout.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { Collection } from '../../collections/config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { APIError } from '../../errors/index.js'\n\nexport type Arguments = {\n  allSessions?: boolean\n  collection: Collection\n  req: PayloadRequest\n}\n\nexport const logoutOperation = async (incomingArgs: Arguments): Promise<boolean> => {\n  let args = incomingArgs\n  const {\n    allSessions,\n    collection: { config: collectionConfig },\n    req: { user },\n    req,\n  } = incomingArgs\n\n  if (!user) {\n    throw new APIError('No User', httpStatus.BAD_REQUEST)\n  }\n  if (user.collection !== collectionConfig.slug) {\n    throw new APIError('Incorrect collection', httpStatus.FORBIDDEN)\n  }\n\n  if (collectionConfig.hooks?.afterLogout?.length) {\n    for (const hook of collectionConfig.hooks.afterLogout) {\n      args =\n        (await hook({\n          collection: args.collection?.config,\n          context: req.context,\n          req,\n        })) || args\n    }\n  }\n\n  if (collectionConfig.auth.disableLocalStrategy !== true && collectionConfig.auth.useSessions) {\n    const userWithSessions = await req.payload.db.findOne<{\n      id: number | string\n      sessions: { id: string }[]\n    }>({\n      collection: collectionConfig.slug,\n      req,\n      where: {\n        id: {\n          equals: user.id,\n        },\n      },\n    })\n\n    if (!userWithSessions) {\n      throw new APIError('No User', httpStatus.BAD_REQUEST)\n    }\n\n    if (allSessions) {\n      userWithSessions.sessions = []\n    } else {\n      const sessionsAfterLogout = (userWithSessions?.sessions || []).filter(\n        (s) => s.id !== req?.user?._sid,\n      )\n\n      userWithSessions.sessions = sessionsAfterLogout\n    }\n\n    await req.payload.db.updateOne({\n      id: user.id,\n      collection: collectionConfig.slug,\n      data: userWithSessions,\n      returning: false,\n    })\n  }\n\n  return true\n}\n"],"names":["status","httpStatus","APIError","logoutOperation","incomingArgs","args","allSessions","collection","config","collectionConfig","req","user","BAD_REQUEST","slug","FORBIDDEN","hooks","afterLogout","length","hook","context","auth","disableLocalStrategy","useSessions","userWithSessions","payload","db","findOne","where","id","equals","sessions","sessionsAfterLogout","filter","s","_sid","updateOne","data","returning"],"mappings":"AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,QAAQ,QAAQ,wBAAuB;AAQhD,OAAO,MAAMC,kBAAkB,OAAOC;IACpC,IAAIC,OAAOD;IACX,MAAM,EACJE,WAAW,EACXC,YAAY,EAAEC,QAAQC,gBAAgB,EAAE,EACxCC,KAAK,EAAEC,IAAI,EAAE,EACbD,GAAG,EACJ,GAAGN;IAEJ,IAAI,CAACO,MAAM;QACT,MAAM,IAAIT,SAAS,WAAWD,WAAWW,WAAW;IACtD;IACA,IAAID,KAAKJ,UAAU,KAAKE,iBAAiBI,IAAI,EAAE;QAC7C,MAAM,IAAIX,SAAS,wBAAwBD,WAAWa,SAAS;IACjE;IAEA,IAAIL,iBAAiBM,KAAK,EAAEC,aAAaC,QAAQ;QAC/C,KAAK,MAAMC,QAAQT,iBAAiBM,KAAK,CAACC,WAAW,CAAE;YACrDX,OACE,AAAC,MAAMa,KAAK;gBACVX,YAAYF,KAAKE,UAAU,EAAEC;gBAC7BW,SAAST,IAAIS,OAAO;gBACpBT;YACF,MAAOL;QACX;IACF;IAEA,IAAII,iBAAiBW,IAAI,CAACC,oBAAoB,KAAK,QAAQZ,iBAAiBW,IAAI,CAACE,WAAW,EAAE;QAC5F,MAAMC,mBAAmB,MAAMb,IAAIc,OAAO,CAACC,EAAE,CAACC,OAAO,CAGlD;YACDnB,YAAYE,iBAAiBI,IAAI;YACjCH;YACAiB,OAAO;gBACLC,IAAI;oBACFC,QAAQlB,KAAKiB,EAAE;gBACjB;YACF;QACF;QAEA,IAAI,CAACL,kBAAkB;YACrB,MAAM,IAAIrB,SAAS,WAAWD,WAAWW,WAAW;QACtD;QAEA,IAAIN,aAAa;YACfiB,iBAAiBO,QAAQ,GAAG,EAAE;QAChC,OAAO;YACL,MAAMC,sBAAsB,AAACR,CAAAA,kBAAkBO,YAAY,EAAE,AAAD,EAAGE,MAAM,CACnE,CAACC,IAAMA,EAAEL,EAAE,KAAKlB,KAAKC,MAAMuB;YAG7BX,iBAAiBO,QAAQ,GAAGC;QAC9B;QAEA,MAAMrB,IAAIc,OAAO,CAACC,EAAE,CAACU,SAAS,CAAC;YAC7BP,IAAIjB,KAAKiB,EAAE;YACXrB,YAAYE,iBAAiBI,IAAI;YACjCuB,MAAMb;YACNc,WAAW;QACb;IACF;IAEA,OAAO;AACT,EAAC"}