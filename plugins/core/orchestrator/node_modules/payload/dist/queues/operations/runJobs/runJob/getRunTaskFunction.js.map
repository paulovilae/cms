{"version":3,"sources":["../../../../../src/queues/operations/runJobs/runJob/getRunTaskFunction.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { Job } from '../../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../../types/index.js'\nimport type {\n  RetryConfig,\n  RunInlineTaskFunction,\n  RunTaskFunction,\n  RunTaskFunctions,\n  TaskConfig,\n  TaskHandler,\n  TaskHandlerResult,\n  TaskType,\n} from '../../../config/types/taskTypes.js'\nimport type {\n  SingleTaskStatus,\n  WorkflowConfig,\n  WorkflowTypes,\n} from '../../../config/types/workflowTypes.js'\nimport type { UpdateJobFunction } from './getUpdateJobFunction.js'\n\nimport { TaskError } from '../../../errors/index.js'\nimport { getTaskHandlerFromConfig } from './importHandlerPath.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport type TaskParent = {\n  taskID: string\n  taskSlug: string\n}\n\nexport const getRunTaskFunction = <TIsInline extends boolean>(\n  job: Job,\n  workflowConfig: WorkflowConfig,\n  req: PayloadRequest,\n  isInline: TIsInline,\n  updateJob: UpdateJobFunction,\n  parent?: TaskParent,\n): TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions => {\n  const jobConfig = req.payload.config.jobs\n\n  const runTask: <TTaskSlug extends string>(\n    taskSlug: TTaskSlug,\n  ) => TTaskSlug extends 'inline' ? RunInlineTaskFunction : RunTaskFunction<TTaskSlug> = (\n    taskSlug,\n  ) =>\n    (async (\n      taskID: Parameters<RunInlineTaskFunction>[0],\n      {\n        input,\n        retries,\n        // Only available for inline tasks:\n        task,\n      }: Parameters<RunInlineTaskFunction>[1] & Parameters<RunTaskFunction<string>>[1],\n    ) => {\n      const executedAt = new Date()\n\n      let taskConfig: TaskConfig | undefined\n      if (!isInline) {\n        taskConfig = (jobConfig.tasks?.length &&\n          jobConfig.tasks.find((t) => t.slug === taskSlug)) as TaskConfig<string>\n\n        if (!taskConfig) {\n          throw new Error(`Task ${taskSlug} not found in workflow ${job.workflowSlug}`)\n        }\n      }\n\n      const retriesConfigFromPropsNormalized =\n        retries == undefined || retries == null\n          ? {}\n          : typeof retries === 'number'\n            ? { attempts: retries }\n            : retries\n      const retriesConfigFromTaskConfigNormalized = taskConfig\n        ? typeof taskConfig.retries === 'number'\n          ? { attempts: taskConfig.retries }\n          : taskConfig.retries\n        : {}\n\n      const finalRetriesConfig: RetryConfig = {\n        ...retriesConfigFromTaskConfigNormalized,\n        ...retriesConfigFromPropsNormalized, // Retry config from props takes precedence\n      }\n\n      const taskStatus: null | SingleTaskStatus<string> = job?.taskStatus?.[taskSlug]\n        ? job.taskStatus[taskSlug][taskID]!\n        : null\n\n      // Handle restoration of task if it succeeded in a previous run\n      if (taskStatus && taskStatus.complete === true) {\n        let shouldRestore = true\n        if (finalRetriesConfig?.shouldRestore === false) {\n          shouldRestore = false\n        } else if (typeof finalRetriesConfig?.shouldRestore === 'function') {\n          shouldRestore = await finalRetriesConfig.shouldRestore({\n            input: input!,\n            job,\n            req,\n            taskStatus,\n          })\n        }\n        if (shouldRestore) {\n          return taskStatus.output\n        }\n      }\n\n      const runner = isInline\n        ? (task as TaskHandler<TaskType>)\n        : await getTaskHandlerFromConfig(taskConfig)\n\n      if (!runner || typeof runner !== 'function') {\n        throw new TaskError({\n          executedAt,\n          input,\n          job,\n          message: isInline\n            ? `Inline task with ID ${taskID} does not have a valid handler.`\n            : `Task with slug ${taskSlug} in workflow ${job.workflowSlug} does not have a valid handler.`,\n          parent,\n          retriesConfig: finalRetriesConfig,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          workflowConfig,\n        })\n      }\n\n      let taskHandlerResult: TaskHandlerResult<string>\n      let output: JsonObject | undefined = {}\n\n      try {\n        taskHandlerResult = await runner({\n          inlineTask: getRunTaskFunction(job, workflowConfig, req, true, updateJob, {\n            taskID,\n            taskSlug,\n          }),\n          input,\n          job: job as unknown as Job<WorkflowTypes>,\n          req,\n          tasks: getRunTaskFunction(job, workflowConfig, req, false, updateJob, {\n            taskID,\n            taskSlug,\n          }),\n        })\n      } catch (err: any) {\n        throw new TaskError({\n          executedAt,\n          input: input!,\n          job,\n          message: err.message || 'Task handler threw an error',\n          output,\n          parent,\n          retriesConfig: finalRetriesConfig,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          workflowConfig,\n        })\n      }\n\n      if (taskHandlerResult.state === 'failed') {\n        throw new TaskError({\n          executedAt,\n          input: input!,\n          job,\n          message: taskHandlerResult.errorMessage ?? 'Task handler returned a failed state',\n          output,\n          parent,\n          retriesConfig: finalRetriesConfig,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          workflowConfig,\n        })\n      } else {\n        output = taskHandlerResult.output\n      }\n\n      if (taskConfig?.onSuccess) {\n        await taskConfig.onSuccess()\n      }\n\n      ;(job.log ??= []).push({\n        id: new ObjectId().toHexString(),\n        completedAt: new Date().toISOString(),\n        executedAt: executedAt.toISOString(),\n        input,\n        output,\n        parent: jobConfig.addParentToTaskLog ? parent : undefined,\n        state: 'succeeded',\n        taskID,\n        taskSlug,\n      })\n\n      await updateJob({\n        log: job.log,\n      })\n\n      return output\n    }) as any\n\n  if (isInline) {\n    return runTask('inline') as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  } else {\n    const tasks: RunTaskFunctions = {}\n    for (const task of jobConfig.tasks ?? []) {\n      tasks[task.slug] = runTask(task.slug) as RunTaskFunction<string>\n    }\n    return tasks as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  }\n}\n"],"names":["ObjectIdImport","TaskError","getTaskHandlerFromConfig","ObjectId","default","getRunTaskFunction","job","workflowConfig","req","isInline","updateJob","parent","jobConfig","payload","config","jobs","runTask","taskSlug","taskID","input","retries","task","executedAt","Date","taskConfig","tasks","length","find","t","slug","Error","workflowSlug","retriesConfigFromPropsNormalized","undefined","attempts","retriesConfigFromTaskConfigNormalized","finalRetriesConfig","taskStatus","complete","shouldRestore","output","runner","message","retriesConfig","taskHandlerResult","inlineTask","err","state","errorMessage","onSuccess","log","push","id","toHexString","completedAt","toISOString","addParentToTaskLog"],"mappings":"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"}