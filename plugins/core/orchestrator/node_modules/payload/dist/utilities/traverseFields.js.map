{"version":3,"sources":["../../src/utilities/traverseFields.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from '../config/types.js'\nimport type { ArrayField, Block, BlocksField, Field, TabAsField } from '../fields/config/types.js'\n\nimport {\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldShouldBeLocalized,\n  tabHasName,\n} from '../fields/config/types.js'\n\nconst traverseArrayOrBlocksField = ({\n  callback,\n  callbackStack,\n  config,\n  data,\n  field,\n  fillEmpty,\n  leavesFirst,\n  parentIsLocalized,\n  parentPath,\n  parentRef,\n}: {\n  callback: TraverseFieldsCallback\n  callbackStack: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  data: Record<string, unknown>[]\n  field: ArrayField | BlocksField\n  fillEmpty: boolean\n  leavesFirst: boolean\n  parentIsLocalized: boolean\n  parentPath?: string\n  parentRef?: unknown\n}) => {\n  if (fillEmpty) {\n    if (field.type === 'array') {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields: field.fields,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: `${parentPath}${field.name}.`,\n        parentRef,\n      })\n    }\n    if (field.type === 'blocks') {\n      for (const _block of field.blockReferences ?? field.blocks) {\n        // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n        const block =\n          typeof _block === 'string' ? config?.blocks?.find((b) => b.slug === _block) : _block\n        if (block) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: block.fields,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: `${parentPath}${field.name}.`,\n            parentRef,\n          })\n        }\n      }\n    }\n    return\n  }\n  for (const ref of data) {\n    let fields!: Field[]\n    if (field.type === 'blocks' && typeof ref?.blockType === 'string') {\n      // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n      const block = field.blockReferences\n        ? ((config?.blocks?.find((b) => b.slug === ref.blockType) ??\n            field.blockReferences.find(\n              (b) => typeof b !== 'string' && b.slug === ref.blockType,\n            )) as Block)\n        : field.blocks.find((b) => b.slug === ref.blockType)\n\n      fields = block?.fields as Field[]\n    } else if (field.type === 'array') {\n      fields = field.fields\n    }\n\n    if (fields) {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields,\n        fillEmpty,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: `${parentPath}${field.name}.`,\n        parentRef,\n        ref,\n      })\n    }\n  }\n}\n\nexport type TraverseFieldsCallback = (args: {\n  /**\n   * The current field\n   */\n  field: Field | TabAsField\n  /**\n   * Function that when called will skip the current field and continue to the next\n   */\n  next?: () => void\n  parentIsLocalized: boolean\n  parentPath: string\n  /**\n   * The parent reference object\n   */\n  parentRef?: Record<string, unknown> | unknown\n  /**\n   * The current reference object\n   */\n  ref?: Record<string, unknown> | unknown\n}) => boolean | void\n\ntype TraverseFieldsArgs = {\n  callback: TraverseFieldsCallback\n  callbackStack?: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  fields: (Field | TabAsField)[]\n  fillEmpty?: boolean\n  isTopLevel?: boolean\n  /**\n   * @default false\n   *\n   * if this is `true`, the callback functions of the leaf fields will be called before the parent fields.\n   * The return value of the callback function will be ignored.\n   */\n  leavesFirst?: boolean\n  parentIsLocalized?: boolean\n  parentPath?: string\n  parentRef?: Record<string, unknown> | unknown\n  ref?: Record<string, unknown> | unknown\n}\n\n/**\n * Iterate a recurse an array of fields, calling a callback for each field\n *\n * @param fields\n * @param callback callback called for each field, discontinue looping if callback returns truthy\n * @param fillEmpty fill empty properties to use this without data\n * @param ref the data or any artifacts assigned in the callback during field recursion\n * @param parentRef the data or any artifacts assigned in the callback during field recursion one level up\n */\nexport const traverseFields = ({\n  callback,\n  callbackStack: _callbackStack = [],\n  config,\n  fields,\n  fillEmpty = true,\n  isTopLevel = true,\n  leavesFirst = false,\n  parentIsLocalized,\n  parentPath = '',\n  parentRef = {},\n  ref = {},\n}: TraverseFieldsArgs): void => {\n  fields.some((field) => {\n    let callbackStack: (() => ReturnType<TraverseFieldsCallback>)[] = []\n    if (!isTopLevel) {\n      callbackStack = _callbackStack\n    }\n    let skip = false\n    const next = () => {\n      skip = true\n    }\n\n    if (!ref || typeof ref !== 'object') {\n      return\n    }\n\n    if (\n      !leavesFirst &&\n      callback &&\n      callback({ field, next, parentIsLocalized: parentIsLocalized!, parentPath, parentRef, ref })\n    ) {\n      return true\n    } else if (leavesFirst) {\n      callbackStack.push(() =>\n        callback({\n          field,\n          next,\n          parentIsLocalized: parentIsLocalized!,\n          parentPath,\n          parentRef,\n          ref,\n        }),\n      )\n    }\n\n    if (skip) {\n      return false\n    }\n\n    // avoid mutation of ref for all fields\n    let currentRef = ref\n    let currentParentRef = parentRef\n\n    if (field.type === 'tabs' && 'tabs' in field) {\n      for (const tab of field.tabs) {\n        let tabRef = ref\n\n        if (skip) {\n          return false\n        }\n\n        if ('name' in tab && tab.name) {\n          if (\n            !ref[tab.name as keyof typeof ref] ||\n            typeof ref[tab.name as keyof typeof ref] !== 'object'\n          ) {\n            if (fillEmpty) {\n              if (tab.localized) {\n                ;(ref as Record<string, any>)[tab.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[tab.name] = {}\n              }\n            } else {\n              continue\n            }\n          }\n\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentPath,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentPath,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n\n          tabRef = tabRef[tab.name as keyof typeof tabRef]\n\n          if (tab.localized) {\n            for (const key in tabRef as Record<string, unknown>) {\n              if (\n                tabRef[key as keyof typeof tabRef] &&\n                typeof tabRef[key as keyof typeof tabRef] === 'object'\n              ) {\n                traverseFields({\n                  callback,\n                  callbackStack,\n                  config,\n                  fields: tab.fields,\n                  fillEmpty,\n                  isTopLevel: false,\n                  leavesFirst,\n                  parentIsLocalized: true,\n                  parentPath: `${parentPath}${tab.name}.`,\n                  parentRef: currentParentRef,\n                  ref: tabRef[key as keyof typeof tabRef],\n                })\n              }\n            }\n          }\n        } else {\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentPath,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentPath,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n        }\n\n        if (!tab.localized) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: tab.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: false,\n            parentPath: tabHasName(tab) ? `${parentPath}${tab.name}` : parentPath,\n            parentRef: currentParentRef,\n            ref: tabRef,\n          })\n        }\n\n        if (skip) {\n          return false\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'tab' || fieldHasSubFields(field) || field.type === 'blocks') {\n      if ('name' in field && field.name) {\n        currentParentRef = currentRef\n        if (!ref[field.name as keyof typeof ref]) {\n          if (fillEmpty) {\n            if (field.type === 'group' || field.type === 'tab') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = {}\n              }\n            } else if (field.type === 'array' || field.type === 'blocks') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: [] }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = []\n              }\n            }\n          } else {\n            return\n          }\n        }\n        currentRef = ref[field.name as keyof typeof ref]\n      }\n\n      if (\n        (field.type === 'tab' || field.type === 'group') &&\n        fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! }) &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        if (fieldAffectsData(field)) {\n          for (const key in currentRef as Record<string, unknown>) {\n            if (currentRef[key as keyof typeof currentRef]) {\n              traverseFields({\n                callback,\n                callbackStack,\n                config,\n                fields: field.fields,\n                fillEmpty,\n                isTopLevel: false,\n                leavesFirst,\n                parentIsLocalized: true,\n                parentPath: field.name ? `${parentPath}${field.name}` : parentPath,\n                parentRef: currentParentRef,\n                ref: currentRef[key as keyof typeof currentRef],\n              })\n            }\n          }\n        } else {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: field.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized,\n            parentRef: currentParentRef,\n            ref: currentRef,\n          })\n        }\n\n        return\n      }\n\n      if (\n        (field.type === 'blocks' || field.type === 'array') &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n          if (Array.isArray(currentRef)) {\n            return\n          }\n\n          for (const key in currentRef as Record<string, unknown>) {\n            const localeData = currentRef[key as keyof typeof currentRef]\n            if (!Array.isArray(localeData)) {\n              continue\n            }\n\n            traverseArrayOrBlocksField({\n              callback,\n              callbackStack,\n              config,\n              data: localeData,\n              field,\n              fillEmpty,\n              leavesFirst,\n              parentIsLocalized: true,\n              parentRef: currentParentRef,\n            })\n          }\n        } else if (Array.isArray(currentRef)) {\n          traverseArrayOrBlocksField({\n            callback,\n            callbackStack,\n            config,\n            data: currentRef as Record<string, unknown>[],\n            field,\n            fillEmpty,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized!,\n            parentRef: currentParentRef,\n          })\n        }\n      } else if (currentRef && typeof currentRef === 'object' && 'fields' in field) {\n        traverseFields({\n          callback,\n          callbackStack,\n          config,\n          fields: field.fields,\n          fillEmpty,\n          isTopLevel: false,\n          leavesFirst,\n          parentIsLocalized,\n          parentPath,\n          parentRef: currentParentRef,\n          ref: currentRef,\n        })\n      }\n    }\n\n    if (isTopLevel) {\n      callbackStack.reverse().forEach((cb) => {\n        cb()\n      })\n    }\n  })\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldShouldBeLocalized","tabHasName","traverseArrayOrBlocksField","callback","callbackStack","config","data","field","fillEmpty","leavesFirst","parentIsLocalized","parentPath","parentRef","type","traverseFields","fields","isTopLevel","localized","name","_block","blockReferences","blocks","block","find","b","slug","ref","blockType","_callbackStack","some","skip","next","push","currentRef","currentParentRef","tab","tabs","tabRef","en","key","Array","isArray","localeData","reverse","forEach","cb"],"mappings":"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"}