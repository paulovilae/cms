{"version":3,"sources":["../../../src/fields/config/sanitize.ts"],"sourcesContent":["import { deepMergeSimple } from '@payloadcms/translations/utilities'\nimport { v4 as uuid } from 'uuid'\n\nimport type {\n  CollectionConfig,\n  SanitizedJoin,\n  SanitizedJoins,\n} from '../../collections/config/types.js'\nimport type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { Field } from './types.js'\n\nimport {\n  DuplicateFieldName,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  MissingEditorProp,\n  MissingFieldType,\n} from '../../errors/index.js'\nimport { ReservedFieldName } from '../../errors/ReservedFieldName.js'\nimport { formatLabels, toWords } from '../../utilities/formatLabels.js'\nimport { baseBlockFields } from '../baseFields/baseBlockFields.js'\nimport { baseIDField } from '../baseFields/baseIDField.js'\nimport { baseTimezoneField } from '../baseFields/timezone/baseField.js'\nimport { defaultTimezones } from '../baseFields/timezone/defaultTimezones.js'\nimport { setDefaultBeforeDuplicate } from '../setDefaultBeforeDuplicate.js'\nimport { validations } from '../validations.js'\nimport {\n  reservedAPIKeyFieldNames,\n  reservedBaseAuthFieldNames,\n  reservedBaseUploadFieldNames,\n  reservedVerifyFieldNames,\n} from './reservedFieldNames.js'\nimport { sanitizeJoinField } from './sanitizeJoinField.js'\nimport { fieldAffectsData as _fieldAffectsData, fieldIsLocalized, tabHasName } from './types.js'\n\ntype Args = {\n  collectionConfig?: CollectionConfig\n  config: Config\n  existingFieldNames?: Set<string>\n  fields: Field[]\n  /**\n   * Used to prevent unnecessary sanitization of fields that are not top-level.\n   */\n  isTopLevelField?: boolean\n  joinPath?: string\n  /**\n   * When not passed in, assume that join are not supported (globals, arrays, blocks)\n   */\n  joins?: SanitizedJoins\n  parentIsLocalized: boolean\n  polymorphicJoins?: SanitizedJoin[]\n  /**\n   * If true, a richText field will require an editor property to be set, as the sanitizeFields function will not add it from the payload config if not present.\n   *\n   * @default false\n   */\n  requireFieldLevelRichTextEditor?: boolean\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>\n  /**\n   * If not null, will validate that upload and relationship fields do not relate to a collection that is not in this array.\n   * This validation will be skipped if validRelationships is null.\n   */\n  validRelationships: null | string[]\n}\n\nexport const sanitizeFields = async ({\n  collectionConfig,\n  config,\n  existingFieldNames = new Set(),\n  fields,\n  isTopLevelField = true,\n  joinPath = '',\n  joins,\n  parentIsLocalized,\n  polymorphicJoins,\n  requireFieldLevelRichTextEditor = false,\n  richTextSanitizationPromises,\n  validRelationships,\n}: Args): Promise<Field[]> => {\n  if (!fields) {\n    return []\n  }\n\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]!\n\n    if ('_sanitized' in field && field._sanitized === true) {\n      continue\n    }\n\n    if ('_sanitized' in field) {\n      field._sanitized = true\n    }\n\n    if (!field.type) {\n      throw new MissingFieldType(field)\n    }\n\n    const fieldAffectsData = _fieldAffectsData(field)\n\n    if (isTopLevelField && fieldAffectsData && field.name) {\n      if (collectionConfig && collectionConfig.upload) {\n        if (reservedBaseUploadFieldNames.includes(field.name)) {\n          throw new ReservedFieldName(field, field.name)\n        }\n      }\n\n      if (\n        collectionConfig &&\n        collectionConfig.auth &&\n        typeof collectionConfig.auth === 'object' &&\n        !collectionConfig.auth.disableLocalStrategy\n      ) {\n        if (reservedBaseAuthFieldNames.includes(field.name)) {\n          throw new ReservedFieldName(field, field.name)\n        }\n\n        if (collectionConfig.auth.verify) {\n          // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n          if (reservedAPIKeyFieldNames.includes(field.name)) {\n            throw new ReservedFieldName(field, field.name)\n          }\n\n          // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n          if (reservedVerifyFieldNames.includes(field.name)) {\n            throw new ReservedFieldName(field, field.name)\n          }\n        }\n      }\n    }\n\n    // assert that field names do not contain forbidden characters\n    if (fieldAffectsData && field.name.includes('.')) {\n      throw new InvalidFieldName(field, field.name)\n    }\n\n    // Auto-label\n    if (\n      'name' in field &&\n      field.name &&\n      typeof field.label !== 'object' &&\n      typeof field.label !== 'string' &&\n      typeof field.label !== 'function' &&\n      field.label !== false\n    ) {\n      field.label = toWords(field.name)\n    }\n\n    if (\n      field.type === 'checkbox' &&\n      typeof field.defaultValue === 'undefined' &&\n      field.required === true\n    ) {\n      field.defaultValue = false\n    }\n\n    if (field.type === 'join') {\n      sanitizeJoinField({ config, field, joinPath, joins, parentIsLocalized, polymorphicJoins })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (validRelationships) {\n        const relationships = Array.isArray(field.relationTo)\n          ? field.relationTo\n          : [field.relationTo]\n\n        relationships.forEach((relationship: string) => {\n          if (!validRelationships.includes(relationship)) {\n            throw new InvalidFieldRelationship(field, relationship)\n          }\n        })\n      }\n\n      if (field.min && !field.minRows) {\n        console.warn(\n          `(payload): The \"min\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"minRows\" instead.`,\n        )\n        field.minRows = field.min\n      }\n\n      if (field.max && !field.maxRows) {\n        console.warn(\n          `(payload): The \"max\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"maxRows\" instead.`,\n        )\n        field.maxRows = field.max\n      }\n    }\n\n    if (field.type === 'upload') {\n      if (!field.admin || !('isSortable' in field.admin)) {\n        field.admin = {\n          isSortable: true,\n          ...field.admin,\n        }\n      }\n    }\n\n    if (field.type === 'array' && field.fields) {\n      const hasCustomID = field.fields.some((f) => 'name' in f && f.name === 'id')\n      if (!hasCustomID) {\n        field.fields.push(baseIDField)\n      }\n    }\n\n    if ((field.type === 'blocks' || field.type === 'array') && field.label) {\n      field.labels = field.labels || formatLabels(field.name)\n    }\n\n    if (fieldAffectsData) {\n      if (existingFieldNames.has(field.name)) {\n        throw new DuplicateFieldName(field.name)\n      } else if (!['blockName', 'id'].includes(field.name)) {\n        existingFieldNames.add(field.name)\n      }\n\n      if (typeof field.localized !== 'undefined') {\n        let shouldDisableLocalized = !config.localization\n\n        if (\n          process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized !== 'true' &&\n          parentIsLocalized &&\n          // @todo PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY=true will be the default in 4.0\n          process.env.PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY !== 'true'\n        ) {\n          shouldDisableLocalized = true\n        }\n\n        if (shouldDisableLocalized) {\n          delete field.localized\n        }\n      }\n\n      if (typeof field.validate === 'undefined') {\n        const defaultValidate = validations[field.type as keyof typeof validations]\n        if (defaultValidate) {\n          field.validate = (val: any, options: any) =>\n            defaultValidate(val, { ...field, ...options })\n        } else {\n          field.validate = (): true => true\n        }\n      }\n\n      if (!field.hooks) {\n        field.hooks = {}\n      }\n\n      if (!field.access) {\n        field.access = {}\n      }\n\n      setDefaultBeforeDuplicate(field, parentIsLocalized)\n    }\n\n    if (!field.admin) {\n      field.admin = {}\n    }\n\n    // Make sure that the richText field has an editor\n    if (field.type === 'richText') {\n      const sanitizeRichText = async (_config: SanitizedConfig) => {\n        if (!field.editor) {\n          if (_config.editor && !requireFieldLevelRichTextEditor) {\n            // config.editor should be sanitized at this point\n            field.editor = _config.editor\n          } else {\n            throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n          }\n        }\n\n        if (typeof field.editor === 'function') {\n          field.editor = await field.editor({\n            config: _config,\n            isRoot: requireFieldLevelRichTextEditor,\n            parentIsLocalized: (parentIsLocalized || field.localized)!,\n          })\n        }\n\n        if (field.editor.i18n && Object.keys(field.editor.i18n).length >= 0) {\n          config.i18n!.translations = deepMergeSimple(config.i18n!.translations!, field.editor.i18n)\n        }\n      }\n      if (richTextSanitizationPromises) {\n        richTextSanitizationPromises.push(sanitizeRichText)\n      } else {\n        await sanitizeRichText(config as unknown as SanitizedConfig)\n      }\n    }\n\n    if (field.type === 'blocks' && field.blocks) {\n      if (field.blockReferences && field.blocks?.length) {\n        throw new Error('You cannot have both blockReferences and blocks in the same blocks field')\n      }\n\n      const blockSlugs: string[] = []\n\n      for (const block of field.blockReferences ?? field.blocks) {\n        const blockSlug = typeof block === 'string' ? block : block.slug\n\n        if (blockSlugs.includes(blockSlug)) {\n          throw new DuplicateFieldName(blockSlug)\n        }\n\n        blockSlugs.push(blockSlug)\n\n        if (typeof block === 'string') {\n          continue\n        }\n\n        if (block._sanitized === true) {\n          continue\n        }\n\n        block._sanitized = true\n        block.fields = block.fields.concat(baseBlockFields)\n        block.labels = !block.labels ? formatLabels(block.slug) : block.labels\n        block.fields = await sanitizeFields({\n          collectionConfig,\n          config,\n          existingFieldNames: new Set(),\n          fields: block.fields,\n          isTopLevelField: false,\n          parentIsLocalized: (parentIsLocalized || field.localized)!,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n      }\n    }\n\n    if ('fields' in field && field.fields) {\n      field.fields = await sanitizeFields({\n        collectionConfig,\n        config,\n        existingFieldNames: fieldAffectsData ? new Set() : existingFieldNames,\n        fields: field.fields,\n        isTopLevelField: isTopLevelField && !fieldAffectsData,\n        joinPath: fieldAffectsData ? `${joinPath ? joinPath + '.' : ''}${field.name}` : joinPath,\n        joins,\n        parentIsLocalized: parentIsLocalized || fieldIsLocalized(field),\n        polymorphicJoins,\n        requireFieldLevelRichTextEditor,\n        richTextSanitizationPromises,\n        validRelationships,\n      })\n    }\n\n    if (field.type === 'tabs') {\n      for (let j = 0; j < field.tabs.length; j++) {\n        const tab = field.tabs[j]!\n\n        const isNamedTab = tabHasName(tab)\n\n        if (isNamedTab && typeof tab.label === 'undefined') {\n          tab.label = toWords(tab.name)\n        }\n\n        if (\n          'admin' in tab &&\n          tab.admin?.condition &&\n          typeof tab.admin.condition === 'function' &&\n          !tab.id\n        ) {\n          // Always attach a UUID to tabs with a condition so there's no conflicts even if there are duplicate nested names\n          tab.id = isNamedTab ? `${tab.name}_${uuid()}` : uuid()\n        }\n\n        tab.fields = await sanitizeFields({\n          collectionConfig,\n          config,\n          existingFieldNames: isNamedTab ? new Set() : existingFieldNames,\n          fields: tab.fields,\n          isTopLevelField: isTopLevelField && !isNamedTab,\n          joinPath: isNamedTab ? `${joinPath ? joinPath + '.' : ''}${tab.name}` : joinPath,\n          joins,\n          parentIsLocalized: parentIsLocalized || (isNamedTab && tab.localized)!,\n          polymorphicJoins,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n\n        field.tabs[j] = tab\n      }\n    }\n\n    if (field.type === 'ui' && typeof field.admin.disableBulkEdit === 'undefined') {\n      field.admin.disableBulkEdit = true\n    }\n\n    fields[i] = field\n\n    // Insert our field after assignment\n    if (field.type === 'date' && field.timezone) {\n      const name = field.name + '_tz'\n      const defaultTimezone = config.admin?.timezones?.defaultTimezone\n\n      const supportedTimezones = config.admin?.timezones?.supportedTimezones\n\n      const options =\n        typeof supportedTimezones === 'function'\n          ? supportedTimezones({ defaultTimezones })\n          : supportedTimezones\n\n      // Need to set the options here manually so that any database enums are generated correctly\n      // The UI component will import the options from the config\n      const timezoneField = baseTimezoneField({\n        name,\n        defaultValue: defaultTimezone,\n        options,\n        required: field.required,\n      })\n\n      fields.splice(++i, 0, timezoneField)\n    }\n  }\n\n  return fields\n}\n"],"names":["deepMergeSimple","v4","uuid","DuplicateFieldName","InvalidFieldName","InvalidFieldRelationship","MissingEditorProp","MissingFieldType","ReservedFieldName","formatLabels","toWords","baseBlockFields","baseIDField","baseTimezoneField","defaultTimezones","setDefaultBeforeDuplicate","validations","reservedAPIKeyFieldNames","reservedBaseAuthFieldNames","reservedBaseUploadFieldNames","reservedVerifyFieldNames","sanitizeJoinField","fieldAffectsData","_fieldAffectsData","fieldIsLocalized","tabHasName","sanitizeFields","collectionConfig","config","existingFieldNames","Set","fields","isTopLevelField","joinPath","joins","parentIsLocalized","polymorphicJoins","requireFieldLevelRichTextEditor","richTextSanitizationPromises","validRelationships","i","length","field","_sanitized","type","name","upload","includes","auth","disableLocalStrategy","verify","label","defaultValue","required","relationships","Array","isArray","relationTo","forEach","relationship","min","minRows","console","warn","max","maxRows","admin","isSortable","hasCustomID","some","f","push","labels","has","add","localized","shouldDisableLocalized","localization","process","env","NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized","PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY","validate","defaultValidate","val","options","hooks","access","sanitizeRichText","_config","editor","isRoot","i18n","Object","keys","translations","blocks","blockReferences","Error","blockSlugs","block","blockSlug","slug","concat","j","tabs","tab","isNamedTab","condition","id","disableBulkEdit","timezone","defaultTimezone","timezones","supportedTimezones","timezoneField","splice"],"mappings":"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"}