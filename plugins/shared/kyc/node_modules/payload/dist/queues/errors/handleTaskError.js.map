{"version":3,"sources":["../../../src/queues/errors/handleTaskError.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { PayloadRequest } from '../../index.js'\nimport type { UpdateJobFunction } from '../operations/runJobs/runJob/getUpdateJobFunction.js'\nimport type { TaskError } from './index.js'\n\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\nimport { getWorkflowRetryBehavior } from './getWorkflowRetryBehavior.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport async function handleTaskError({\n  error,\n  req,\n  updateJob,\n}: {\n  error: TaskError\n  req: PayloadRequest\n  updateJob: UpdateJobFunction\n}): Promise<{\n  hasFinalError: boolean\n}> {\n  const {\n    executedAt,\n    input,\n    job,\n    output,\n    parent,\n    retriesConfig,\n    taskConfig,\n    taskID,\n    taskSlug,\n    taskStatus,\n    workflowConfig,\n  } = error.args\n\n  if (taskConfig?.onFail) {\n    await taskConfig.onFail()\n  }\n\n  const errorJSON = {\n    name: error.name,\n    cancelled: Boolean('cancelled' in error && error.cancelled),\n    message: error.message,\n    stack: error.stack,\n  }\n\n  const currentDate = new Date()\n\n  ;(job.log ??= []).push({\n    id: new ObjectId().toHexString(),\n    completedAt: currentDate.toISOString(),\n    error: errorJSON,\n    executedAt: executedAt.toISOString(),\n    input,\n    output: output ?? {},\n    parent: req.payload.config.jobs.addParentToTaskLog ? parent : undefined,\n    state: 'failed',\n    taskID,\n    taskSlug,\n  })\n\n  if (job.waitUntil) {\n    // Check if waitUntil is in the past\n    const waitUntil = new Date(job.waitUntil)\n    if (waitUntil < currentDate) {\n      // Outdated waitUntil, remove it\n      delete job.waitUntil\n    }\n  }\n\n  let maxRetries: number = 0\n\n  if (retriesConfig?.attempts === undefined || retriesConfig?.attempts === null) {\n    // Inherit retries from workflow config, if they are undefined and the workflow config has retries configured\n    if (workflowConfig.retries !== undefined && workflowConfig.retries !== null) {\n      maxRetries =\n        typeof workflowConfig.retries === 'object'\n          ? typeof workflowConfig.retries.attempts === 'number'\n            ? workflowConfig.retries.attempts\n            : 0\n          : workflowConfig.retries\n    } else {\n      maxRetries = 0\n    }\n  } else {\n    maxRetries = retriesConfig.attempts\n  }\n\n  if (!taskStatus?.complete && (taskStatus?.totalTried ?? 0) >= maxRetries) {\n    /**\n     * Task reached max retries => workflow will not retry\n     */\n\n    await updateJob({\n      error: errorJSON,\n      hasError: true,\n      log: job.log,\n      processing: false,\n      totalTried: (job.totalTried ?? 0) + 1,\n      waitUntil: job.waitUntil,\n    })\n\n    req.payload.logger.error({\n      err: error,\n      job,\n      msg: `Error running task ${taskID}. Attempt ${job.totalTried} - max retries reached`,\n      taskSlug,\n    })\n    return {\n      hasFinalError: true,\n    }\n  }\n\n  /**\n   * Task can retry:\n   * - If workflow can retry, allow it to retry\n   * - If workflow reached max retries, do not retry and set final error\n   */\n\n  // First set task waitUntil - if the workflow waitUntil is later, it will be updated later\n  const taskWaitUntil: Date = calculateBackoffWaitUntil({\n    retriesConfig,\n    totalTried: taskStatus?.totalTried ?? 0,\n  })\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (!job.waitUntil || taskWaitUntil > new Date(job.waitUntil)) {\n    job.waitUntil = taskWaitUntil.toISOString()\n  }\n\n  const { hasFinalError, maxWorkflowRetries, waitUntil } = getWorkflowRetryBehavior({\n    job,\n    retriesConfig: workflowConfig.retries,\n  })\n\n  req.payload.logger.error({\n    err: error,\n    job,\n    msg: `Error running task ${taskID}. Attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,\n    taskSlug,\n  })\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (waitUntil && (!job.waitUntil || waitUntil > new Date(job.waitUntil))) {\n    job.waitUntil = waitUntil.toISOString()\n  }\n\n  // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n  // we need to ensure the job is updated to reflect the error\n  await updateJob({\n    error: hasFinalError ? errorJSON : undefined,\n    hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n    log: job.log,\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n    waitUntil: job.waitUntil,\n  })\n\n  return {\n    hasFinalError,\n  }\n}\n"],"names":["ObjectIdImport","calculateBackoffWaitUntil","getWorkflowRetryBehavior","ObjectId","default","handleTaskError","error","req","updateJob","executedAt","input","job","output","parent","retriesConfig","taskConfig","taskID","taskSlug","taskStatus","workflowConfig","args","onFail","errorJSON","name","cancelled","Boolean","message","stack","currentDate","Date","log","push","id","toHexString","completedAt","toISOString","payload","config","jobs","addParentToTaskLog","undefined","state","waitUntil","maxRetries","attempts","retries","complete","totalTried","hasError","processing","logger","err","msg","hasFinalError","taskWaitUntil","maxWorkflowRetries"],"mappings":"AAAA,OAAOA,oBAAoB,gBAAe;AAM1C,SAASC,yBAAyB,QAAQ,iCAAgC;AAC1E,SAASC,wBAAwB,QAAQ,gCAA+B;AAExE,MAAMC,WAAYH,eAAeI,OAAO,IACtCJ;AAEF,OAAO,eAAeK,gBAAgB,EACpCC,KAAK,EACLC,GAAG,EACHC,SAAS,EAKV;IAGC,MAAM,EACJC,UAAU,EACVC,KAAK,EACLC,GAAG,EACHC,MAAM,EACNC,MAAM,EACNC,aAAa,EACbC,UAAU,EACVC,MAAM,EACNC,QAAQ,EACRC,UAAU,EACVC,cAAc,EACf,GAAGb,MAAMc,IAAI;IAEd,IAAIL,YAAYM,QAAQ;QACtB,MAAMN,WAAWM,MAAM;IACzB;IAEA,MAAMC,YAAY;QAChBC,MAAMjB,MAAMiB,IAAI;QAChBC,WAAWC,QAAQ,eAAenB,SAASA,MAAMkB,SAAS;QAC1DE,SAASpB,MAAMoB,OAAO;QACtBC,OAAOrB,MAAMqB,KAAK;IACpB;IAEA,MAAMC,cAAc,IAAIC;IAEtBlB,CAAAA,IAAImB,GAAG,KAAK,EAAE,AAAD,EAAGC,IAAI,CAAC;QACrBC,IAAI,IAAI7B,WAAW8B,WAAW;QAC9BC,aAAaN,YAAYO,WAAW;QACpC7B,OAAOgB;QACPb,YAAYA,WAAW0B,WAAW;QAClCzB;QACAE,QAAQA,UAAU,CAAC;QACnBC,QAAQN,IAAI6B,OAAO,CAACC,MAAM,CAACC,IAAI,CAACC,kBAAkB,GAAG1B,SAAS2B;QAC9DC,OAAO;QACPzB;QACAC;IACF;IAEA,IAAIN,IAAI+B,SAAS,EAAE;QACjB,oCAAoC;QACpC,MAAMA,YAAY,IAAIb,KAAKlB,IAAI+B,SAAS;QACxC,IAAIA,YAAYd,aAAa;YAC3B,gCAAgC;YAChC,OAAOjB,IAAI+B,SAAS;QACtB;IACF;IAEA,IAAIC,aAAqB;IAEzB,IAAI7B,eAAe8B,aAAaJ,aAAa1B,eAAe8B,aAAa,MAAM;QAC7E,6GAA6G;QAC7G,IAAIzB,eAAe0B,OAAO,KAAKL,aAAarB,eAAe0B,OAAO,KAAK,MAAM;YAC3EF,aACE,OAAOxB,eAAe0B,OAAO,KAAK,WAC9B,OAAO1B,eAAe0B,OAAO,CAACD,QAAQ,KAAK,WACzCzB,eAAe0B,OAAO,CAACD,QAAQ,GAC/B,IACFzB,eAAe0B,OAAO;QAC9B,OAAO;YACLF,aAAa;QACf;IACF,OAAO;QACLA,aAAa7B,cAAc8B,QAAQ;IACrC;IAEA,IAAI,CAAC1B,YAAY4B,YAAY,AAAC5B,CAAAA,YAAY6B,cAAc,CAAA,KAAMJ,YAAY;QACxE;;KAEC,GAED,MAAMnC,UAAU;YACdF,OAAOgB;YACP0B,UAAU;YACVlB,KAAKnB,IAAImB,GAAG;YACZmB,YAAY;YACZF,YAAY,AAACpC,CAAAA,IAAIoC,UAAU,IAAI,CAAA,IAAK;YACpCL,WAAW/B,IAAI+B,SAAS;QAC1B;QAEAnC,IAAI6B,OAAO,CAACc,MAAM,CAAC5C,KAAK,CAAC;YACvB6C,KAAK7C;YACLK;YACAyC,KAAK,CAAC,mBAAmB,EAAEpC,OAAO,UAAU,EAAEL,IAAIoC,UAAU,CAAC,sBAAsB,CAAC;YACpF9B;QACF;QACA,OAAO;YACLoC,eAAe;QACjB;IACF;IAEA;;;;GAIC,GAED,0FAA0F;IAC1F,MAAMC,gBAAsBrD,0BAA0B;QACpDa;QACAiC,YAAY7B,YAAY6B,cAAc;IACxC;IAEA,8EAA8E;IAC9E,IAAI,CAACpC,IAAI+B,SAAS,IAAIY,gBAAgB,IAAIzB,KAAKlB,IAAI+B,SAAS,GAAG;QAC7D/B,IAAI+B,SAAS,GAAGY,cAAcnB,WAAW;IAC3C;IAEA,MAAM,EAAEkB,aAAa,EAAEE,kBAAkB,EAAEb,SAAS,EAAE,GAAGxC,yBAAyB;QAChFS;QACAG,eAAeK,eAAe0B,OAAO;IACvC;IAEAtC,IAAI6B,OAAO,CAACc,MAAM,CAAC5C,KAAK,CAAC;QACvB6C,KAAK7C;QACLK;QACAyC,KAAK,CAAC,mBAAmB,EAAEpC,OAAO,UAAU,EAAEL,IAAIoC,UAAU,GAAG,IAAIQ,uBAAuBf,YAAY,MAAOe,CAAAA,qBAAqB,CAAA,IAAK,IAAI;QAC3ItC;IACF;IAEA,8EAA8E;IAC9E,IAAIyB,aAAc,CAAA,CAAC/B,IAAI+B,SAAS,IAAIA,YAAY,IAAIb,KAAKlB,IAAI+B,SAAS,CAAA,GAAI;QACxE/B,IAAI+B,SAAS,GAAGA,UAAUP,WAAW;IACvC;IAEA,4HAA4H;IAC5H,4DAA4D;IAC5D,MAAM3B,UAAU;QACdF,OAAO+C,gBAAgB/B,YAAYkB;QACnCQ,UAAUK;QACVvB,KAAKnB,IAAImB,GAAG;QACZmB,YAAY;QACZF,YAAY,AAACpC,CAAAA,IAAIoC,UAAU,IAAI,CAAA,IAAK;QACpCL,WAAW/B,IAAI+B,SAAS;IAC1B;IAEA,OAAO;QACLW;IACF;AACF"}