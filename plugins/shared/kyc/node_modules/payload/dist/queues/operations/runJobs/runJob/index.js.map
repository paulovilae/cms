{"version":3,"sources":["../../../../../src/queues/operations/runJobs/runJob/index.ts"],"sourcesContent":["import type { Job } from '../../../../index.js'\nimport type { PayloadRequest } from '../../../../types/index.js'\nimport type { WorkflowConfig, WorkflowHandler } from '../../../config/types/workflowTypes.js'\nimport type { UpdateJobFunction } from './getUpdateJobFunction.js'\n\nimport { handleTaskError } from '../../../errors/handleTaskError.js'\nimport { handleWorkflowError } from '../../../errors/handleWorkflowError.js'\nimport { JobCancelledError, TaskError, WorkflowError } from '../../../errors/index.js'\nimport { getRunTaskFunction } from './getRunTaskFunction.js'\n\ntype Args = {\n  job: Job\n  req: PayloadRequest\n  updateJob: UpdateJobFunction\n  workflowConfig: WorkflowConfig\n  workflowHandler: WorkflowHandler\n}\n\nexport type JobRunStatus = 'error' | 'error-reached-max-retries' | 'success'\n\nexport type RunJobResult = {\n  status: JobRunStatus\n}\n\nexport const runJob = async ({\n  job,\n  req,\n  updateJob,\n  workflowConfig,\n  workflowHandler,\n}: Args): Promise<RunJobResult> => {\n  // Run the job\n  try {\n    await workflowHandler({\n      inlineTask: getRunTaskFunction(job, workflowConfig, req, true, updateJob),\n      job,\n      req,\n      tasks: getRunTaskFunction(job, workflowConfig, req, false, updateJob),\n    })\n  } catch (error) {\n    if (error instanceof JobCancelledError) {\n      throw error // Job cancellation is handled in a top-level error handler, as higher up code may themselves throw this error\n    }\n    if (error instanceof TaskError) {\n      const { hasFinalError } = await handleTaskError({\n        error,\n        req,\n        updateJob,\n      })\n\n      return {\n        status: hasFinalError ? 'error-reached-max-retries' : 'error',\n      }\n    }\n\n    const { hasFinalError } = await handleWorkflowError({\n      error:\n        error instanceof WorkflowError\n          ? error\n          : new WorkflowError({\n              job,\n              message:\n                typeof error === 'object' && error && 'message' in error\n                  ? (error.message as string)\n                  : 'An unhandled error occurred',\n              workflowConfig,\n            }),\n      req,\n      updateJob,\n    })\n\n    return {\n      status: hasFinalError ? 'error-reached-max-retries' : 'error',\n    }\n  }\n\n  // Workflow has completed successfully\n  await updateJob({\n    completedAt: new Date().toISOString(),\n    log: job.log,\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n  })\n\n  return {\n    status: 'success',\n  }\n}\n"],"names":["handleTaskError","handleWorkflowError","JobCancelledError","TaskError","WorkflowError","getRunTaskFunction","runJob","job","req","updateJob","workflowConfig","workflowHandler","inlineTask","tasks","error","hasFinalError","status","message","completedAt","Date","toISOString","log","processing","totalTried"],"mappings":"AAKA,SAASA,eAAe,QAAQ,qCAAoC;AACpE,SAASC,mBAAmB,QAAQ,yCAAwC;AAC5E,SAASC,iBAAiB,EAAEC,SAAS,EAAEC,aAAa,QAAQ,2BAA0B;AACtF,SAASC,kBAAkB,QAAQ,0BAAyB;AAgB5D,OAAO,MAAMC,SAAS,OAAO,EAC3BC,GAAG,EACHC,GAAG,EACHC,SAAS,EACTC,cAAc,EACdC,eAAe,EACV;IACL,cAAc;IACd,IAAI;QACF,MAAMA,gBAAgB;YACpBC,YAAYP,mBAAmBE,KAAKG,gBAAgBF,KAAK,MAAMC;YAC/DF;YACAC;YACAK,OAAOR,mBAAmBE,KAAKG,gBAAgBF,KAAK,OAAOC;QAC7D;IACF,EAAE,OAAOK,OAAO;QACd,IAAIA,iBAAiBZ,mBAAmB;YACtC,MAAMY,MAAM,8GAA8G;;QAC5H;QACA,IAAIA,iBAAiBX,WAAW;YAC9B,MAAM,EAAEY,aAAa,EAAE,GAAG,MAAMf,gBAAgB;gBAC9Cc;gBACAN;gBACAC;YACF;YAEA,OAAO;gBACLO,QAAQD,gBAAgB,8BAA8B;YACxD;QACF;QAEA,MAAM,EAAEA,aAAa,EAAE,GAAG,MAAMd,oBAAoB;YAClDa,OACEA,iBAAiBV,gBACbU,QACA,IAAIV,cAAc;gBAChBG;gBACAU,SACE,OAAOH,UAAU,YAAYA,SAAS,aAAaA,QAC9CA,MAAMG,OAAO,GACd;gBACNP;YACF;YACNF;YACAC;QACF;QAEA,OAAO;YACLO,QAAQD,gBAAgB,8BAA8B;QACxD;IACF;IAEA,sCAAsC;IACtC,MAAMN,UAAU;QACdS,aAAa,IAAIC,OAAOC,WAAW;QACnCC,KAAKd,IAAIc,GAAG;QACZC,YAAY;QACZC,YAAY,AAAChB,CAAAA,IAAIgB,UAAU,IAAI,CAAA,IAAK;IACtC;IAEA,OAAO;QACLP,QAAQ;IACV;AACF,EAAC"}