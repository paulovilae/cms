{"version":3,"sources":["../../src/uploads/generateFileData.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs/promises'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, Forbidden, MissingFile } from '../errors/index.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { checkFileRestrictions } from './checkFileRestrictions.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { resizeAndTransformImageSizes } from './imageResizer.js'\nimport { isImage } from './isImage.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc?: T\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  isDuplicating,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    isDuplicating,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    constructorOptions = {},\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n    withMetadata,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  const incomingFileData = isDuplicating ? originalDoc : data\n\n  if (!file && uploadEdits && incomingFileData) {\n    const { filename, url } = incomingFileData as unknown as FileData\n\n    if (filename && (filename.includes('../') || filename.includes('..\\\\'))) {\n      throw new Forbidden(req.t)\n    }\n\n    try {\n      if (url && url.startsWith('/') && !disableLocalStorage) {\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        overwriteExistingFiles = true\n      } else if (filename && url) {\n        file = await getExternalFile({\n          data: incomingFileData as unknown as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        overwriteExistingFiles = true\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (isDuplicating) {\n    overwriteExistingFiles = false\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) {\n      throw new MissingFile(req.t)\n    }\n\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  await checkFileRestrictions({\n    collection: collectionConfig,\n    file,\n    req,\n  })\n\n  if (!disableLocalStorage) {\n    await fs.mkdir(staticPath!, { recursive: true })\n  }\n\n  let newData = data\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer!: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(\n        resizeOptions || formatOptions || trimOptions || constructorOptions || file.tempFilePath,\n      )\n\n    const sharpOptions: SharpOptions = { ...constructorOptions }\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      sharpFile = await optionallyAppendMetadata({\n        req,\n        sharpFile,\n        withMetadata: withMetadata!,\n      })\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = (await fileTypeFromBuffer(fileBuffer.data))!) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop()?.split('?')[0]\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adjust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') {\n      mime = 'image/svg+xml'\n    }\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        req,\n        staticPath: staticPath!,\n      })\n    }\n\n    fileData.filename = fsSafeName\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({\n        cropData,\n        dimensions: dimensions!,\n        file,\n        heightInPixels: uploadEdits.heightInPixels!,\n        req,\n        sharp,\n        widthInPixels: uploadEdits.widthInPixels!,\n        withMetadata,\n      })\n\n      // Apply resize after cropping to ensure it conforms to resizeOptions\n      if (resizeOptions && !resizeOptions.withoutEnlargement) {\n        const resizedAfterCrop = await sharp(croppedImage)\n          .resize({\n            fit: resizeOptions?.fit || 'cover',\n            height: resizeOptions?.height,\n            position: resizeOptions?.position || 'center',\n            width: resizeOptions?.width,\n          })\n          .toBuffer({ resolveWithObject: true })\n\n        filesToSave.push({\n          buffer: resizedAfterCrop.data,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...fileForResize,\n          data: resizedAfterCrop.data,\n          size: resizedAfterCrop.info.size,\n        }\n\n        fileData.width = resizedAfterCrop.info.width\n        fileData.height = resizedAfterCrop.info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages\n            ? resizedAfterCrop.info.height / metadata.pages\n            : resizedAfterCrop.info.height\n        }\n        fileData.filesize = resizedAfterCrop.info.size\n      } else {\n        // If resizeOptions is not present, just save the cropped image\n        filesToSave.push({\n          buffer: croppedImage,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...file,\n          data: croppedImage,\n          size: info.size,\n        }\n\n        fileData.width = info.width\n        fileData.height = info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n        }\n        fileData.filesize = info.size\n      }\n\n      if (file.tempFilePath) {\n        await fs.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      const { focalPoint, sizeData, sizesToSave } = await resizeAndTransformImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions!\n          : {\n              ...dimensions,\n              height: fileData.height!,\n              width: fileData.width!,\n            },\n        file: fileForResize,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath: staticPath!,\n        uploadEdits,\n        withMetadata,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequest\n}): UploadEdits {\n  const { data, isDuplicating, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const uploadEdits =\n    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'\n      ? (req.query.uploadEdits as UploadEdits)\n      : {}\n\n  if (uploadEdits.focalPoint) {\n    return uploadEdits\n  }\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {\n    // If no change in focal point, return undefined.\n    // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n    if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n      return undefined!\n    }\n\n    if (isDuplicating) {\n      uploadEdits.focalPoint = {\n        x: incomingData?.focalX || origDoc.focalX!,\n        y: incomingData?.focalY || origDoc.focalX!,\n      }\n    }\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","FileRetrievalError","FileUploadError","Forbidden","MissingFile","canResizeImage","checkFileRestrictions","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","resizeAndTransformImageSizes","isImage","optionallyAppendMetadata","generateFileData","collection","config","collectionConfig","data","isDuplicating","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","sharp","payload","file","uploadEdits","parseUploadEditsFromReqOrIncomingData","constructorOptions","disableLocalStorage","focalPoint","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","withMetadata","staticPath","incomingFileData","filename","url","includes","t","startsWith","filePath","response","uploadConfig","err","Error","message","undefined","mkdir","recursive","newData","filesToSave","fileData","fileIsAnimatedType","mimetype","cropData","crop","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","heightInPixels","widthInPixels","withoutEnlargement","resizedAfterCrop","fit","position","push","buffer","path","writeFile","Array","isArray","payloadUploadSizes","sizeData","sizesToSave","savedFilename","sizes","focalX","x","focalY","y","logger","error","args","query","incomingData","origDoc"],"mappings":"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"}